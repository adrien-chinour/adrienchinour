---
title: "Les structures de donn√©es en PHP"
date: 2020-12-27
slug: "/les-structures-de-donnees-en-php"
tags:
  - PHP
---

Array, array ou array ? Oui c'est vrai que PHP n'est pas riche en structure de donn√©es mais voyons
ensemble un peu ce qu'il en est r√©ellement ? üòä

<div style="text-align:center">
  <img src="migration-php8/elephpant.jpg" width="100%" height="auto" />
</div>

## Les **array**

La structure de donn√©es par excellence en PHP c'est array, elle est _quasiment_ seule et on l'utilise comme liste,
table de hachage, pile, file, etc.
C'est plut√¥t utile notamment pour les d√©butants qui ne se retrouve pas √©touffer par le typage fort de certains langages.
Mais c'est aussi √ßa qui en fait un langage d√©test√© par de nombreux d√©veloppeur. üëπ

Voyons d√©j√† le fonctionnement de cette structure de donn√©e _magique_... üßê

_Array_ est en r√©alit√© un **dictionnaire ordonn√©**, avec un couple cl√©/valeur. Dans le cas o√π l'on ne d√©fini pas de cl√© alors
PHP d√©fini des cl√©s num√©rique : 0, 1, 2, etc. Pour faire le lien entre cette cl√© et la valeur une table de hachage est cr√©√©e.

Je ne vais pas rentrer dans les d√©tails, je vous laisse lire <a rel="noreferrer noopener" target="_blank" href="http://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html">cet article</a> de Nikita Popov
qui explique en d√©tail l'√©volution entre **PHP 5** et **PHP 7** sur l'impl√©mentation des tableaux en PHP.

> La documentation de Zend fourni aussi une explication tr√®s claire sur l'impl√©mentation et l'API interne de PHP pour les arrays : <a rel="noreferrer noopener" target="_blank" href="https://www.zend.com/php-arrays">PHP Arrays</a>

Et le gros probl√®me avec cette impl√©mentation c'est que m√™me si √ßa r√©pond √† un grand nombre de cas on a parfois des performances d√©sastreuses
sur certaines applications juste parce que l'on utilise des functions PHP tr√®s peu performante.

Prenons le cas de <a rel="noreferrer noopener" target="_blank" href="https://www.php.net/manual/fr/function.array-shift.php">`array_shift`</a> qui permet d'extraire le premier √©l√©ment d'un array.
De part sa structure interne un array avec des cl√©s num√©rique va d√©caler chacune d'elles lors d'un `array_shift` ce qui cause une complexit√© de O(n). üò±
Sur des petits tableau l'op√©ration n'est pas forc√©ment couteuse mais lorsqu'on manipule des tableaux plus grands cela peut vraiment √™tre un probl√®me.
Ainsi il est moins couteux de faire un `array_reverse` puis `array_pop` lorsque les index du tableau ne sont pas important.

```php
$stack = array("orange", "banana", "apple", "raspberry");

// bad perf
$fruit = array_shift($stack);

// better perf
$stack = array_reverse($stack);
$fruit = array_pop($stack);
```

Des cas comme √ßa il y en a pas √©norm√©ment et il est vrai uniquement sur des gros volumes de donn√©es mais on peut tout de m√™me
se poser la question des alternatives, que ce soit pour le confort et la compr√©hension du code comme de la performance.

## Il est o√π l'objet ? Il est o√π ? üé∂

D√©j√† un gros probl√®me que j'ai avec les tableaux en PHP, c'est que ce ne sont pas des objets il faut passer par des fonctions
qui ne sont pas toujours simple √† utiliser. M√™me apr√®s plusieurs ann√©es, je n'arrive pas √† me souvenir de l'ordre des param√®tres
ou si le tableau est pass√© par r√©f√©rence ou par valeur. üò§

Prenons l'exemple suivant qui va calculer la moyenne des notes dans un tableau associatif :

```php
$data = [
    ['name' => 'Jean', 'note' => 8],
    ['name' => 'Alice', 'note' => 12],
    ['name' => 'Marcel', 'note' => 3],
    ['name' => 'Bob', 'note' => 18],
    ['name' => 'Elodie', 'note' => null],
];

$notes = array_filter(array_column($data, 'note'), fn($item) => null !== $item);
$average = array_sum($notes) / count($notes);
```

On comprend ce que cela fait mais honn√™tement la lisibilit√© est pas top, on remarque vite que l'imbrication des fonctions peut vite poser probl√®me.

Une alternative, pour les utilisateurs de Symfony est d'utiliser les Collections Doctrine (_doctrine/collections_).

```php
$collection = (new \Doctrine\Common\Collections\ArrayCollection($data))
    ->map(fn($item) => $item['note'])
    ->filter(fn($item) => null !== $item);
$average = array_sum($collection->toArray()) / $collection->count();
```

> La documentation de <a rel="noreferrer noopener" target="_blank" href="https://www.doctrine-project.org/projects/doctrine-collections/en/1.6/index.html">Doctrine Collection</a>

On ne se simplifie pas forc√©ment la vie, c'est m√™me plus complexe puisque l'on m√©lange la manipulation de notre objet Collection avec les fonctions natives PHP.

L'int√©r√™t de cette librairie est de fournir une impl√©mentation utile pour doctrine dans le traitement des collections d'entit√©s,
elle n'est donc pas faite pour remplacer les fonctions natives de PHP mais peut toujours √™tre utile pour certaines manipulations : map, filtre, etc.

Une autre alternative bien plus int√©ressante pour manipuler les tableaux php est celle fourni par Lavarel : _tightenco/collect_

```php
$average = collect($data)->avg(fn($item) => $item['note']);
```

> La documentation de <a rel="noreferrer noopener" target="_blank" href="https://laravel.com/docs/8.x/collections">Laravel Collection</a>

On obtient un code lisible avec une m√©thode qui vient "wrapper" toute notre logique autour de notre objectif : obtenir la moyenne.
L'int√©r√™t de cette librairie est simplement de fournir au d√©veloppeur un outil plus intuitif et √©voluer que les fonctions natives de PHP.

Je sais que ce cas de la moyenne semble b√™te mais il est cependant bien pratique,
sur un projet ou j'ai eu besoin de calculer plusieurs moyennes avec des quartiles et plein d'autres statistiques √† partir d'√©valuations,
j'y ai trouv√© un gros avantage d'un point de vue exp√©rience d√©veloppeur.

La complexit√© en temps et en m√©moire reste la m√™me puisque ces librairies ne sont que des wrapper objet des fonctions PHP.

Il y a surement d'autres librairies similaires, j'ai trouv√© _voku/arrayy_ par exemple qui semble relativement compl√®te. (<a rel="noreferrer noopener" target="_blank" href="https://github.com/voku/Arrayy">GitHub</a>)

## Et les autres structures de donn√©es ?

Comme on l'a vu au d√©but PHP semble proposer une seule structure de donn√©e (_array_) mais depuis **PHP 7** nous avons la **SPL**...

Gr√¢ce √† la SPL (Standard PHP Library) nous avons des structures de donn√©es suppl√©mentaires pr√©sent√©es dans <a rel="noreferrer noopener" target="_blank" href="https://www.php.net/manual/fr/spl.datastructures.php">la documentation PHP</a>.

> Je vous conseille cette vid√©o qui explique un peu tout ce que je vais dire dans cette partie : <a rel="noreferrer noopener" target="_blank" href="https://www.youtube.com/watch?v=tX1jbqnjrR0">Les structures de donn√©es en PHP - Fr√©d√©ric BOUCHERY - AFUP Day 2020 Nantes</a>

Mais le probl√®me majeur de la SPL est que des op√©rations qui ne devraient pas √™tre pr√©sente dans une structure de donn√©e soit possible.
On se retrouve avec SplStack qui permet de faire des shift/unshift ou des push/pop. ü§®

> TODO parler de SplFixedArray

Une autre extension qui malheureusement n'est pas pr√©sente de base dans PHP est l'extension Data Structure. Elle corrige tous les probl√®mes de la SPL en allant encore plus loin.
Je ne vais pas expliquer en d√©tails les structures disponibles, je vous laisse regarder <a rel="noreferrer noopener" target="_blank" href="https://www.php.net/manual/fr/book.ds.php">la documentation</a>.

D'un point de vue performance il y a un int√©r√™t sur des gros volumes de donn√©es mais comme dans les librairies orient√©es objet pour la manipulation de tableau on am√©liore surtout l'exp√©rience d√©veloppeur.

> Un article traitant des performances <a rel="noreferrer noopener" target="_blank" href="https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd">Efficient data structures for PHP 7</a>.

Pour vous aider √† comprendre l'utilit√© voici un exemple qui reprend le probl√®me de `array_shift` utile lorsqu'on utilise une file :

```php
// FIFO array style
$queue = ['a', 'b'];
$queue[] = 'c'; // on ajoute un √©l√©ment
array_push($queue, 'd'); // la aussi
$item = array_shift($queue); // on enl√®ve le premier √©l√©ment, en O(n)...

// FIFO Spl style
$queue = new SplQueue();
$queue->enqueue('a'); // on ajoute un √©l√©ment √† la fin
$queue->push('b'); // on ajoute aussi un √©l√©ment √† la fin...
$queue->add(2, 'c'); // on peut aussi ajouter √† un index...
$item = $queue->dequeue(); // on enl√®ve le premier √©l√©ment en O(1)

// FIFO DS style
$queue = new \Ds\Queue();
$queue->push("a"); // on ajoute un √©l√©ment
$queue->push("b", "c"); // on ajoute plusieurs √©l√©ments
$queue->push(...["d", "e"]); // on ajoute plusieurs √©l√©ment depuis un array
$item = $queue->pop(); // on enl√®ve le premier √©l√©ment en O(1)
```

Alors oui on peut faire les choses bien avec la Spl ou avec array mais √ßa reste plus sympa avec DS. üòâ

L'utilisation de structure de donn√©es autre que _array_ renforce l'utilisation de PHP dans des domaines annexes au web :
pour des cron ou des t√¢ches asynchrones par exemple. _Array_ est indispensable √† PHP, c'est simple et efficace, mais dans certains
cas **Data Structure** ou **Laravel Collection** rendent les projets bien plus sympa ! ü•≥
